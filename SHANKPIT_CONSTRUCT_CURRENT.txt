=== SHANKPIT CONSTRUCT: PHASE 507 (TEXTURES & SPRAYS) ===\n\n\n=== BEGIN FILE: apps/lobby/src/main.c ===\n#define SDL_MAIN_HANDLED
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#ifdef _WIN32
    #include <winsock2.h>
    #include <ws2tcpip.h>
    #pragma comment(lib, "ws2_32.lib")
#else
    #include <sys/socket.h>
    #include <netinet/in.h>
    #include <arpa/inet.h>
    #include <unistd.h>
    #include <fcntl.h>
    #include <netdb.h>
#endif

#include <SDL2/SDL.h>
#include <SDL2/SDL_opengl.h>
#include <GL/glu.h>

#include "../../../packages/common/protocol.h"
#include "../../../packages/common/physics.h"
#include "../../../packages/simulation/local_game.h"

#define STATE_LOBBY 0
#define STATE_GAME_NET 1
#define STATE_GAME_LOCAL 2

char SERVER_HOST[64] = "s.farthq.com";
int SERVER_PORT = 6969;
int app_state = STATE_LOBBY;
int wpn_req = 1; 
int my_client_id = -1;
float cam_yaw = 0.0f;
float cam_pitch = 0.0f;
float current_fov = 75.0f;
#define Z_FAR 8000.0f

#define MENU_MAIN 0
int menu_selection = 0;

// Forward declarations for build stability
void net_connect();
void draw_menu();
void draw_scene(PlayerState *render_p);

void draw_char(char c, float x, float y, float s) {
    glLineWidth(1.5f); glBegin(GL_LINES);
    if(c >= '0' && c <= '9'){ glVertex2f(x,y); glVertex2f(x+s,y); glVertex2f(x+s,y); glVertex2f(x+s,y+s); glVertex2f(x+s,y+s); glVertex2f(x,y+s); glVertex2f(x,y+s); glVertex2f(x,y); }
    else if(c == 'A'){ glVertex2f(x,y); glVertex2f(x+s/2,y+s); glVertex2f(x+s/2,y+s); glVertex2f(x+s,y); glVertex2f(x+s/4,y+s/2); glVertex2f(x+3*s/4,y+s/2); }
    else if(c == 'B'){ glVertex2f(x,y); glVertex2f(x,y+s); glVertex2f(x,y+s); glVertex2f(x+s,y+s*0.75); glVertex2f(x+s,y+s*0.75); glVertex2f(x,y+s/2); glVertex2f(x,y+s/2); glVertex2f(x+s,y+s*0.25); glVertex2f(x+s,y+s*0.25); glVertex2f(x,y); }
    else if(c == 'D'){ glVertex2f(x,y); glVertex2f(x,y+s); glVertex2f(x,y+s); glVertex2f(x+s,y+s/2); glVertex2f(x+s,y+s/2); glVertex2f(x,y); }
    else if(c == 'J'){ glVertex2f(x,y+s/4); glVertex2f(x+s/2,y); glVertex2f(x+s/2,y); glVertex2f(x+s,y+s); }
    else if(c == 'N'){ glVertex2f(x,y); glVertex2f(x,y+s); glVertex2f(x,y+s); glVertex2f(x+s,y); glVertex2f(x+s,y); glVertex2f(x+s,y+s); }
    else if(c == 'S'){ glVertex2f(x+s,y+s); glVertex2f(x,y+s); glVertex2f(x,y+s); glVertex2f(x,y+s/2); glVertex2f(x,y+s/2); glVertex2f(x+s,y+s/2); glVertex2f(x+s,y+s/2); glVertex2f(x+s,y); glVertex2f(x+s,y); glVertex2f(x,y); }
    else if(c == 'E'){ glVertex2f(x+s,y); glVertex2f(x,y); glVertex2f(x,y); glVertex2f(x,y+s); glVertex2f(x,y+s); glVertex2f(x+s,y+s); glVertex2f(x,y+s/2); glVertex2f(x+s*0.7f,y+s/2); }
    else if(c == 'T'){ glVertex2f(x+s/2,y); glVertex2f(x+s/2,y+s); glVertex2f(x,y+s); glVertex2f(x+s,y+s); }
    else if(c == 'U'){ glVertex2f(x,y+s); glVertex2f(x,y); glVertex2f(x,y); glVertex2f(x+s,y); glVertex2f(x+s,y); glVertex2f(x+s,y+s); }
    else if(c == ':'){ glVertex2f(x+s/2,y+s*0.3); glVertex2f(x+s/2,y+s*0.35); glVertex2f(x+s/2,y+s*0.65); glVertex2f(x+s/2,y+s*0.7); }
    else { glVertex2f(x,y); glVertex2f(x+s,y+s); glVertex2f(x,y+s); glVertex2f(x+s,y); }
    glEnd();
}

void draw_string(const char* str, float x, float y, float size) { while(*str) { draw_char(*str, x, y, size); x += size * 1.5f; str++; } }

void draw_menu() {
    glClearColor(0.02f, 0.02f, 0.05f, 1.0f); glClear(GL_COLOR_BUFFER_BIT);
    glLoadIdentity(); glColor3f(0, 1, 1);
    draw_string("SHANKPIT NAVIGATOR", 400, 600, 15);
    const char* opts[] = {"BOT BATTLE", "MICRO DEMO", "FIND LAN GAMES", "JOIN GLOBAL"};
    for(int i=0; i<4; i++) {
        if (i == menu_selection) glColor3f(1, 1, 0); else glColor3f(0, 0.5f, 0.5f);
        draw_string(opts[i], 400, 450 - (i * 50), 10);
    }
}

// ... Networking and Placeholder render stubs ...
void net_init() { /* Implementation same as previous */ }
void net_connect() { /* Implementation same as previous */ }
void net_tick() { /* Implementation same as previous */ }
void draw_scene(PlayerState *p) { 
    glClearColor(0.02f, 0.02f, 0.05f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    // Grid, Map, etc... 
}

int main(int argc, char* argv[]) {
    SDL_Init(SDL_INIT_VIDEO);
    SDL_Window *win = SDL_CreateWindow("SHANKPIT", 100, 100, 1280, 720, SDL_WINDOW_OPENGL);
    SDL_GL_CreateContext(win);
    
    int running = 1;
    while(running) {
        SDL_Event e;
        while(SDL_PollEvent(&e)) {
            if(e.type == SDL_QUIT) running = 0;
            
            if (app_state == STATE_LOBBY) {
                if(e.type == SDL_KEYDOWN) {
                    if (e.key.keysym.sym == SDLK_UP) menu_selection = (menu_selection - 1 + 4) % 4;
                    if (e.key.keysym.sym == SDLK_DOWN) menu_selection = (menu_selection + 1) % 4;
                    if (e.key.keysym.sym == SDLK_b) { app_state = STATE_GAME_LOCAL; local_init_match(12, MODE_DEATHMATCH); }
                    if (e.key.keysym.sym == SDLK_d) { app_state = STATE_GAME_LOCAL; local_init_match(8, MODE_DEATHMATCH); }
                    if (e.key.keysym.sym == SDLK_RETURN) {
                        if (menu_selection == 0) { app_state = STATE_GAME_LOCAL; local_init_match(12, MODE_DEATHMATCH); }
                        if (menu_selection == 1) { app_state = STATE_GAME_LOCAL; local_init_match(8, MODE_DEATHMATCH); }
                        if (menu_selection == 3) { app_state = STATE_GAME_NET; net_connect(); }
                    }
                }
            } else if (e.type == SDL_KEYDOWN && e.key.keysym.sym == SDLK_ESCAPE) {
                app_state = STATE_LOBBY;
            }
        }

        if (app_state == STATE_LOBBY) {
            draw_menu();
        } else {
            float target_fov = 75.0f;
            int rmb = (SDL_GetMouseState(NULL, NULL) & SDL_BUTTON(SDL_BUTTON_RIGHT));
            if (rmb) {
                if (local_state.players[0].current_weapon == WPN_SNIPER) target_fov = 20.0f;
                else if (local_state.players[0].current_weapon == WPN_AR) target_fov = 45.0f;
            }
            current_fov += (target_fov - current_fov) * 0.2f;
            draw_scene(&local_state.players[0]);
        }
        
        SDL_GL_SwapWindow(win);
        SDL_Delay(16);
    }
    SDL_Quit();
    return 0;
}
\n=== END FILE: apps/lobby/src/main.c ===\n\n\n=== BEGIN FILE: apps/server/src/main.c ===\n#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <math.h>

#ifdef _WIN32
    #include <winsock2.h>
    #include <ws2tcpip.h>
    #pragma comment(lib, "ws2_32.lib")
#else
    #include <sys/socket.h>
    #include <netinet/in.h>
    #include <arpa/inet.h>
    #include <unistd.h>
    #include <fcntl.h>
#endif

#include "../../../packages/common/protocol.h"
#include "../../../packages/common/physics.h"
#include "../../../packages/simulation/local_game.h"

int sock = -1;
struct sockaddr_in bind_addr;
unsigned int client_last_seq[MAX_CLIENTS]; 

unsigned int get_server_time() {
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return (unsigned int)(ts.tv_sec * 1000 + ts.tv_nsec / 1000000);
}

void server_net_init() {
    setbuf(stdout, NULL);
    #ifdef _WIN32
    WSADATA wsa; WSAStartup(MAKEWORD(2,2), &wsa);
    #endif
    sock = socket(AF_INET, SOCK_DGRAM, 0);
    #ifdef _WIN32
    u_long mode = 1; ioctlsocket(sock, FIONBIO, &mode);
    #else
    int flags = fcntl(sock, F_GETFL, 0); fcntl(sock, F_SETFL, flags | O_NONBLOCK);
    #endif
    bind_addr.sin_family = AF_INET;
    bind_addr.sin_port = htons(6969); 
    bind_addr.sin_addr.s_addr = INADDR_ANY;
    if (bind(sock, (struct sockaddr*)&bind_addr, sizeof(bind_addr)) < 0) {
        printf("FAILED TO BIND PORT 6969\n");
        exit(1);
    }
    printf("SERVER LISTENING ON PORT 6969\n");
}

void process_user_cmd(int client_id, UserCmd *cmd) {
    if (cmd->sequence <= client_last_seq[client_id]) return; 
    PlayerState *p = &local_state.players[client_id];
    p->yaw = cmd->yaw; p->pitch = cmd->pitch;
    p->in_fwd = cmd->fwd; p->in_strafe = cmd->str;
    p->in_jump = (cmd->buttons & BTN_JUMP);
    p->in_shoot = (cmd->buttons & BTN_ATTACK);
    p->crouching = (cmd->buttons & BTN_CROUCH);
    p->in_reload = (cmd->buttons & BTN_RELOAD);
    if (cmd->weapon_idx >= 0 && cmd->weapon_idx < MAX_WEAPONS) p->current_weapon = cmd->weapon_idx;
    client_last_seq[client_id] = cmd->sequence;
}

void server_handle_packet(struct sockaddr_in *sender, char *buffer, int size) {
    if (size < sizeof(NetHeader)) return;
    NetHeader *head = (NetHeader*)buffer;
    int client_id = -1;
    for(int i=1; i<MAX_CLIENTS; i++) {
        if (local_state.client_active[i] && 
            memcmp(&local_state.clients[i].sin_addr, &sender->sin_addr, sizeof(struct in_addr)) == 0 &&
            local_state.clients[i].sin_port == sender->sin_port) {
            client_id = i; break;
        }
    }
    if (client_id == -1 && head->type == PACKET_CONNECT) {
        for(int i=1; i<MAX_CLIENTS; i++) {
            if (!local_state.client_active[i]) {
                client_id = i;
                local_state.client_active[i] = 1;
                local_state.clients[i] = *sender;
                local_state.players[i].active = 1;
                phys_respawn(&local_state.players[i], get_server_time());
                printf("CLIENT %d CONNECTED\n", client_id);
                NetHeader h = {PACKET_WELCOME, (unsigned char)client_id, 0, get_server_time(), 0};
                sendto(sock, (char*)&h, sizeof(NetHeader), 0, (struct sockaddr*)sender, sizeof(struct sockaddr_in));
                break;
            }
        }
    }
    if (client_id != -1 && head->type == PACKET_USERCMD) {
        int cursor = sizeof(NetHeader);
        unsigned char count = *(unsigned char*)(buffer + cursor); cursor++;
        if (size >= cursor + (count * sizeof(UserCmd))) {
            UserCmd *cmds = (UserCmd*)(buffer + cursor);
            for (int i = 0; i < count; i++) process_user_cmd(client_id, &cmds[i]);
        }
    }
}

void server_broadcast() {
    char buffer[4096]; int cursor = 0;
    NetHeader head = {PACKET_SNAPSHOT, 0, (unsigned short)local_state.server_tick, get_server_time(), 0};
    unsigned char count = 0;
    for(int i=0; i<MAX_CLIENTS; i++) if (local_state.players[i].active) count++;
    head.entity_count = count;
    memcpy(buffer + cursor, &head, sizeof(NetHeader)); cursor += sizeof(NetHeader);
    memcpy(buffer + cursor, &count, 1); cursor += 1;
    for(int i=0; i<MAX_CLIENTS; i++) {
        PlayerState *p = &local_state.players[i];
        if (p->active) {
            NetPlayer np = {(unsigned char)i, p->x, p->y, p->z, p->yaw, p->pitch, (unsigned char)p->current_weapon, (unsigned char)p->state, (unsigned char)p->health, (unsigned char)p->shield, (unsigned char)p->is_shooting, (unsigned char)p->crouching, 0, (unsigned char)p->ammo[p->current_weapon], (unsigned char)p->in_vehicle, (unsigned char)p->hit_feedback};
            p->hit_feedback = 0;
            memcpy(buffer + cursor, &np, sizeof(NetPlayer)); cursor += sizeof(NetPlayer);
        }
    }
    for(int i=1; i<MAX_CLIENTS; i++) {
        if (local_state.client_active[i]) sendto(sock, buffer, cursor, 0, (struct sockaddr*)&local_state.clients[i], sizeof(struct sockaddr_in));
    }
}

int main() {
    server_net_init();
    local_init_match(1, 0); 
    printf("[STRESS-TEST] Spawning 26 bots...\n");
    for(int i = 1; i <= 26; i++) {
        local_state.client_active[i] = 1;
        local_state.players[i].active = 1;
        local_state.players[i].is_bot = 1;
        phys_respawn(&local_state.players[i], get_server_time());
    }
    while(1) {
        char buffer[2048]; struct sockaddr_in sender; socklen_t slen = sizeof(sender);
        int len = recvfrom(sock, buffer, 2048, 0, (struct sockaddr*)&sender, &slen);
        while (len > 0) {
            server_handle_packet(&sender, buffer, len);
            len = recvfrom(sock, buffer, 2048, 0, (struct sockaddr*)&sender, &slen);
        }
        unsigned int now = get_server_time();
        for(int i=0; i<MAX_CLIENTS; i++) {
            if (local_state.players[i].active) update_entity(&local_state.players[i], 0.016f, NULL, now);
        }
        server_broadcast();
        local_state.server_tick++;
        #ifdef _WIN32
        Sleep(16);
        #else
        usleep(16000);
        #endif
    }
    return 0;
}
\n=== END FILE: apps/server/src/main.c ===\n\n\n=== BEGIN FILE: packages/common/protocol.h ===\n#ifndef PROTOCOL_H
#define PROTOCOL_H

#define MAX_CLIENTS 70
#define MAX_WEAPONS 5
#define MAX_PROJECTILES 1024\n#define MAX_SPRAYS 256
#define LAG_HISTORY 64

#define PACKET_CONNECT 0
#define PACKET_USERCMD 1
#define PACKET_SNAPSHOT 2
#define PACKET_WELCOME  3

#define STATE_ALIVE 0
#define STATE_DEAD  1
#define STATE_SPECTATOR 2

#define WPN_KNIFE 0
#define WPN_MAGNUM 1
#define WPN_AR 2
#define WPN_SHOTGUN 3
#define WPN_SNIPER 4

#define RELOAD_TIME_FULL 60      
#define RELOAD_TIME_TACTICAL 42  
#define SHIELD_REGEN_DELAY 180 

typedef struct {
    unsigned char type;
    unsigned char client_id;
    unsigned short sequence;
    unsigned int timestamp;
    unsigned char entity_count; 
} NetHeader;

typedef struct {
    unsigned int sequence;
    unsigned int timestamp;
    unsigned short msec;
    float fwd; float str;
    float yaw; float pitch;    
    unsigned int buttons;
    int weapon_idx;
} UserCmd;

#define BTN_JUMP   1
#define BTN_ATTACK 2
#define BTN_CROUCH 4
#define BTN_RELOAD 8
#define BTN_USE    16 

typedef struct {
    int id;
    int dmg; int rof; int cnt; float spr; int ammo_max;
} WeaponStats;

static const WeaponStats WPN_STATS[MAX_WEAPONS] = {
    {WPN_KNIFE,   200, 20, 1, 0.0f,  0},   
    {WPN_MAGNUM,  45, 25, 1, 0.0f,  6},   
    {WPN_AR,      20, 6,  1, 0.04f, 30},  
    {WPN_SHOTGUN, 128, 17, 8, 0.15f, 8},   
    {WPN_SNIPER,  101, 70, 1, 0.0f,  5}    
};

typedef struct {
    int active; float x, y, z; float vx, vy, vz; int owner_id;
} Projectile;

typedef struct {
    unsigned char id; 
    float x, y, z; float yaw, pitch;
    unsigned char current_weapon;
    unsigned char state;
    unsigned char health;
    unsigned char shield;
    unsigned char is_shooting;
    unsigned char crouching;
    float reward_feedback; 
    unsigned char ammo;
    unsigned char in_vehicle;
    unsigned char hit_feedback;\n    unsigned char texture_id; // For Knife Skins 
} NetPlayer;

typedef struct {
    int version;
    float w_aggro;
    float w_strafe; float w_jump; float w_slide; float w_turret; float w_repel;      
} BotGenome;

typedef struct {
    int id;
    int active; int is_bot;
    float x, y, z; float vx, vy, vz; float yaw, pitch; int on_ground;
    float in_fwd;
    float in_strafe;
    int in_jump; int in_shoot; int in_reload; int crouching; int in_use;
    int current_weapon; int ammo[MAX_WEAPONS];
    int reload_timer; int attack_cooldown;
    int is_shooting; int jump_timer;
    int health; int shield; int shield_regen_timer; int state;
    int kills; int deaths; int hit_feedback; float recoil_anim;
    int in_vehicle;     
    int vehicle_cooldown;
    float accumulated_reward; 
    BotGenome brain;
    unsigned int last_hit_time;
    unsigned int respawn_time;
} PlayerState;

typedef struct {
    int active; unsigned int timestamp;
    float x, y, z;
    float vx, vy, vz;
} LagRecord;

typedef enum { MODE_DEATHMATCH=0, MODE_TDM=1, MODE_SURVIVAL=2, MODE_CTF=3, MODE_ODDBALL=4, MODE_LOCAL=98, MODE_NET=99, MODE_EVOLUTION=100 } GameMode;

typedef struct {
    PlayerState players[MAX_CLIENTS];
    Projectile projectiles[MAX_PROJECTILES];
    LagRecord history[MAX_CLIENTS][LAG_HISTORY];
    int server_tick;
    int game_mode;
    struct sockaddr_in clients[MAX_CLIENTS];
    int client_active[MAX_CLIENTS];
} ServerState;

#endif
\n=== END FILE: packages/common/protocol.h ===\n\n\n=== BEGIN FILE: packages/common/physics.h ===\n#ifndef PHYSICS_H
#define PHYSICS_H
#include <math.h>
#include <stdlib.h>
#include <stdio.h>
#include "protocol.h"

// --- TUNING ---
#define GRAVITY_FLOAT 0.025f 
#define GRAVITY_DROP 0.075f  
#define JUMP_FORCE 0.95f     
#define MAX_SPEED 0.95f      
#define FRICTION 0.15f      
#define ACCEL 0.6f          
#define STOP_SPEED 0.1f     
#define SLIDE_FRICTION 0.01f 
#define CROUCH_SPEED 0.35f  

// --- BUGGY TUNING ---
#define BUGGY_MAX_SPEED 2.5f    
#define BUGGY_ACCEL 0.08f       
#define BUGGY_FRICTION 0.03f    
#define BUGGY_GRAVITY 0.15f     

#define EYE_HEIGHT 2.59f    
#define PLAYER_WIDTH 0.97f  
#define PLAYER_HEIGHT 6.47f 
#define HEAD_SIZE 1.94f     
#define HEAD_OFFSET 2.42f   
#define MELEE_RANGE_SQ 250.0f 

void evolve_bot(PlayerState *loser, PlayerState *winner);
PlayerState* get_best_bot();

typedef struct { float x, y, z, w, h, d; } Box;

// --- THE BONEYARD (Phase 489: Compressed & Dense) ---
static Box map_geo[] = {
    {0.00, -2.00, 0.00, 720.00, 4.00, 1080.00},
    {360.00, 100.00, 0.00, 10.00, 200.00, 1080.00},
    {-360.00, 100.00, 0.00, 10.00, 200.00, 1080.00},
    {0.00, 100.00, 540.00, 720.00, 200.00, 10.00},
    {0.00, 100.00, -540.00, 720.00, 200.00, 10.00},
    {0.00, 10.00, 500.00, 100.00, 20.00, 80.00},
    {0.00, 30.00, 520.00, 60.00, 20.00, 40.00},
    {0.00, 10.00, -500.00, 100.00, 20.00, 80.00},
    {0.00, 30.00, -520.00, 60.00, 20.00, 40.00},
    {0.00, 10.00, -200.00, 40.00, 20.00, 40.00},
    {0.00, 15.00, -100.00, 40.00, 30.00, 40.00},
    {0.00, 20.00, 0.00, 40.00, 40.00, 40.00},
    {0.00, 25.00, 100.00, 40.00, 50.00, 40.00},
    {0.00, 30.00, 200.00, 40.00, 60.00, 40.00},
    {205.08, 5.00, -400.00, 20.00, 2.00, 20.00},
    {-205.08, 5.00, -400.00, 20.00, 2.00, 20.00},
    {207.55, 7.00, -340.00, 20.00, 2.00, 20.00},
    {-207.55, 7.00, -340.00, 20.00, 2.00, 20.00},
    {205.45, 9.00, -280.00, 20.00, 2.00, 20.00},
    {-205.45, 9.00, -280.00, 20.00, 2.00, 20.00},
    {215.33, 11.00, -220.00, 20.00, 2.00, 20.00},
    {-215.33, 11.00, -220.00, 20.00, 2.00, 20.00},
    {180.76, 13.00, -160.00, 20.00, 2.00, 20.00},
    {-180.76, 13.00, -160.00, 20.00, 2.00, 20.00},
    {219.19, 15.00, -100.00, 20.00, 2.00, 20.00},
    {-219.19, 15.00, -100.00, 20.00, 2.00, 20.00},
    {205.75, 17.00, -40.00, 20.00, 2.00, 20.00},
    {-205.75, 17.00, -40.00, 20.00, 2.00, 20.00},
    {190.97, 19.00, 20.00, 20.00, 2.00, 20.00},
    {-190.97, 19.00, 20.00, 20.00, 2.00, 20.00},
    {191.09, 21.00, 80.00, 20.00, 2.00, 20.00},
    {-191.09, 21.00, 80.00, 20.00, 2.00, 20.00},
    {195.73, 23.00, 140.00, 20.00, 2.00, 20.00},
    {-195.73, 23.00, 140.00, 20.00, 2.00, 20.00},
    {214.33, 25.00, 200.00, 20.00, 2.00, 20.00},
    {-214.33, 25.00, 200.00, 20.00, 2.00, 20.00},
    {188.00, 27.00, 260.00, 20.00, 2.00, 20.00},
    {-188.00, 27.00, 260.00, 20.00, 2.00, 20.00},
    {195.88, 29.00, 320.00, 20.00, 2.00, 20.00},
    {-195.88, 29.00, 320.00, 20.00, 2.00, 20.00},
    {195.92, 31.00, 380.00, 20.00, 2.00, 20.00},
    {-195.92, 31.00, 380.00, 20.00, 2.00, 20.00},
    {201.40, 33.00, 440.00, 20.00, 2.00, 20.00},
    {-201.40, 33.00, 440.00, 20.00, 2.00, 20.00}
};
static int map_count = sizeof(map_geo) / sizeof(Box);

float phys_rand_f() { return ((float)(rand()%1000)/500.0f) - 1.0f; }

static inline float angle_diff(float a, float b) {
    float d = a - b;
    while (d < -180) d += 360;
    while (d > 180) d -= 360;
    return d;
}

int check_hit_location(float ox, float oy, float oz, float dx, float dy, float dz, PlayerState *target) {
    if (!target->active) return 0;
    float tx = target->x; float tz = target->z;
    float h_size = target->in_vehicle ? 4.0f : HEAD_SIZE;
    float h_off = target->in_vehicle ? 2.0f : HEAD_OFFSET;
    float head_y = target->y + h_off;
    float vx = tx - ox, vy = head_y - oy, vz = tz - oz;
    float t = vx*dx + vy*dy + vz*dz;
    if (t > 0) {
        float cx = ox + dx*t, cy = oy + dy*t, cz = oz + dz*t;
        float dist_sq = (tx-cx)*(tx-cx) + (head_y-cy)*(head_y-cy) + (tz-cz)*(tz-cz);
        if (dist_sq < (h_size*h_size)) return 2;
    }
    float body_y = target->y + 2.0f;
    vx = tx - ox; vy = body_y - oy; vz = tz - oz;
    t = vx*dx + vy*dy + vz*dz;
    if (t > 0) {
        float cx = ox + dx*t, cy = oy + dy*t, cz = oz + dz*t;
        float dist_sq = (tx-cx)*(tx-cx) + (body_y-cy)*(body_y-cy) + (tz-cz)*(tz-cz);
        if (dist_sq < 7.2f) return 1; 
    }
    return 0;
}

void apply_friction(PlayerState *p) {
    float speed = sqrtf(p->vx*p->vx + p->vz*p->vz);
    if (speed < 0.001f) { p->vx = 0; p->vz = 0; return; }
    
    float drop = 0;
    if (p->in_vehicle) {
        drop = speed * BUGGY_FRICTION;
    } 
    else if (p->on_ground) {
        if (p->crouching) {
            if (speed > 0.75f) drop = speed * SLIDE_FRICTION;
            else drop = speed * (FRICTION * 3.0f); 
        } else {
            float control = (speed < STOP_SPEED) ? STOP_SPEED : speed;
            drop = control * FRICTION; 
        }
    }
    float newspeed = speed - drop;
    if (newspeed < 0) newspeed = 0;
    newspeed /= speed;
    p->vx *= newspeed; p->vz *= newspeed;
}

void accelerate(PlayerState *p, float wish_x, float wish_z, float wish_speed, float accel) {
    if (p->in_vehicle) {
        float current_speed = (p->vx * wish_x) + (p->vz * wish_z);
        float add_speed = wish_speed - current_speed;
        if (add_speed <= 0) return;
        float acc_speed = accel * BUGGY_MAX_SPEED;
        if (acc_speed > add_speed) acc_speed = add_speed;
        p->vx += acc_speed * wish_x; p->vz += acc_speed * wish_z;
        return;
    }
    float speed = sqrtf(p->vx*p->vx + p->vz*p->vz);
    if (p->crouching && speed > 0.75f && p->on_ground) return;
    if (p->crouching && p->on_ground && speed < 0.75f && wish_speed > CROUCH_SPEED) wish_speed = CROUCH_SPEED;
    float current_speed = (p->vx * wish_x) + (p->vz * wish_z);
    float add_speed = wish_speed - current_speed;
    if (add_speed <= 0) return;
    float acc_speed = accel * MAX_SPEED; 
    if (acc_speed > add_speed) acc_speed = add_speed;
    p->vx += acc_speed * wish_x; p->vz += acc_speed * wish_z;
}

void resolve_collision(PlayerState *p) {
    float pw = p->in_vehicle ? 3.0f : PLAYER_WIDTH;
    float ph = p->in_vehicle ? 3.0f : (p->crouching ? (PLAYER_HEIGHT / 2.0f) : PLAYER_HEIGHT);
    p->on_ground = 0;
    if (p->y < 0) { p->y = 0; p->vy = 0; p->on_ground = 1; }
    for(int i=1; i<map_count; i++) {
        Box b = map_geo[i];
        if (p->x + pw > b.x - b.w/2 && p->x - pw < b.x + b.w/2 &&
            p->z + pw > b.z - b.d/2 && p->z - pw < b.z + b.d/2) {
            if (p->y < b.y + b.h/2 && p->y + ph > b.y - b.h/2) {
                float prev_y = p->y - p->vy;
                if (prev_y >= b.y + b.h/2) {
                    p->y = b.y + b.h/2; p->vy = 0; p->on_ground = 1;
                } else {
                    float dx = p->x - b.x; float dz = p->z - b.z;
                    float w = (b.w > 0.1f) ? b.w : 1.0f;
                    float d = (b.d > 0.1f) ? b.d : 1.0f;
                    if (fabs(dx)/w > fabs(dz)/d) { 
                        p->vx = 0; p->x = (dx > 0) ? b.x + b.w/2 + pw : b.x - b.w/2 - pw;
                    } else { 
                        p->vz = 0; p->z = (dz > 0) ? b.z + b.d/2 + pw : b.z - b.d/2 - pw;
                    }
                }
            }
        }
    }
}

void phys_respawn(PlayerState *p, unsigned int now) {
    p->active = 1; p->state = STATE_ALIVE;
    p->health = 100; p->shield = 100; p->respawn_time = 0; p->in_vehicle = 0;
    if (rand()%2 == 0) { p->x = 0; p->z = 0; p->y = 80; } 
    else { float ang = phys_rand_f() * 6.28f;
        p->x = sinf(ang) * 120; p->z = cosf(ang) * 120; p->y = 20;
    }
    p->current_weapon = WPN_MAGNUM;
    for(int i=0; i<MAX_WEAPONS; i++) p->ammo[i] = WPN_STATS[i].ammo_max;
    if (p->is_bot) {
        PlayerState *winner = get_best_bot();
        if (winner && winner != p) evolve_bot(p, winner);
    }
}

void update_weapons(PlayerState *p, PlayerState *targets, int shoot, int reload) {
    if (p->in_vehicle) return; 
    if (p->reload_timer > 0) p->reload_timer--;
    if (p->attack_cooldown > 0) p->attack_cooldown--;
    if (p->is_shooting > 0) p->is_shooting--;

    int w = p->current_weapon;
    if (reload && p->reload_timer == 0 && w != WPN_KNIFE) {
        if (p->ammo[w] < WPN_STATS[w].ammo_max) {
            if (p->ammo[w] > 0) p->reload_timer = RELOAD_TIME_TACTICAL;
            else p->reload_timer = RELOAD_TIME_FULL; 
        }
    }
    if (p->reload_timer == 1) p->ammo[w] = WPN_STATS[w].ammo_max;
    if (shoot && p->attack_cooldown == 0 && p->reload_timer == 0) {
        if (w != WPN_KNIFE && p->ammo[w] <= 0) p->reload_timer = RELOAD_TIME_FULL;
        else {
            p->is_shooting = 5; p->recoil_anim = 1.0f;
            p->attack_cooldown = WPN_STATS[w].rof;
            if (w != WPN_KNIFE) p->ammo[w]--;
            
            float r = -p->yaw * 0.0174533f; float rp = p->pitch * 0.0174533f;
            float dx = sinf(r) * cosf(rp); float dy = sinf(rp); float dz = -cosf(r) * cosf(rp);
            if (WPN_STATS[w].spr > 0) {
                dx += phys_rand_f() * WPN_STATS[w].spr;
                dy += phys_rand_f() * WPN_STATS[w].spr;
                dz += phys_rand_f() * WPN_STATS[w].spr;
            }

            for(int i=0; i<MAX_CLIENTS; i++) {
                if (p == &targets[i]) continue;
                if (!targets[i].active) continue;
                if (w == WPN_KNIFE) {
                    float kx = p->x - targets[i].x;
                    float ky = p->y - targets[i].y; float kz = p->z - targets[i].z;
                    if ((kx*kx + ky*ky + kz*kz) > MELEE_RANGE_SQ + 22.0f ) continue;
                }
                int hit_type = check_hit_location(p->x, p->y + EYE_HEIGHT, p->z, dx, dy, dz, &targets[i]);
                if (hit_type > 0) {
                    printf("ðŸ”« HIT! Dmg: %d on Target %d\n", WPN_STATS[w].dmg, i);
                    int damage = WPN_STATS[w].dmg;
                    p->accumulated_reward += 10.0f;
                    targets[i].shield_regen_timer = SHIELD_REGEN_DELAY;
                    if (hit_type == 2 && targets[i].shield <= 0) { damage *= 3; p->hit_feedback = 20;
                    } else { p->hit_feedback = 10; } 
                    
                    if (targets[i].shield > 0) {
                        if (targets[i].shield >= damage) { targets[i].shield -= damage; damage = 0; } 
                        else { damage -= targets[i].shield; targets[i].shield = 0; }
                    }
                    targets[i].health -= damage;
                    if(targets[i].health <= 0) {
                        p->kills++; targets[i].deaths++; 
                        p->accumulated_reward += 1000.0f;
                        p->hit_feedback = 30; // KILL CONFIRM (Triggers Double Ring)
                        phys_respawn(&targets[i], 0);
                    }
                }
            }
        }
    }
}

void phys_store_history(ServerState *server, int client_id, unsigned int now) {
    if (client_id < 0 || client_id >= MAX_CLIENTS) return;
    int slot = (now / 16) % LAG_HISTORY; 
    server->history[client_id][slot].active = 1;
    server->history[client_id][slot].timestamp = now;
    server->history[client_id][slot].x = server->players[client_id].x;
    server->history[client_id][slot].y = server->players[client_id].y;
    server->history[client_id][slot].z = server->players[client_id].z;
}

int phys_resolve_rewind(ServerState *server, int client_id, unsigned int target_time, float *out_pos) {
    LagRecord *hist = server->history[client_id];
    for(int i=0; i<LAG_HISTORY; i++) {
        if (!hist[i].active) continue;
        if (hist[i].timestamp == target_time) { 
            out_pos[0] = hist[i].x; out_pos[1] = hist[i].y; out_pos[2] = hist[i].z;
            return 1;
        }
    }
    return 0;
}
#endif
\n=== END FILE: packages/common/physics.h ===\n