
--- FILE: apps/lobby/src/main.c ---
#include "../../packages/common/protocol.h"
#ifndef STATE_MENU
#define STATE_MENU 0
#define STATE_PLAYING 1
#define MODE_BOTS 0
#define MODE_DEV 1
#define MODE_SERV 2
#define MODE_NET 3
#define SCREEN_HEIGHT 600
#endif
#include "../../packages/common/protocol.h"
#ifndef STATE_MENU
#define STATE_MENU 0
#define STATE_PLAYING 1
#define MODE_BOTS 0
#define MODE_DEV 1
#define MODE_SERV 2
#define MODE_NET 3
#define SCREEN_HEIGHT 600
#endif

#define SDL_MAIN_HANDLED
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#ifdef _WIN32
    #include <winsock2.h>
    #include <ws2tcpip.h>
    #pragma comment(lib, "ws2_32.lib")
#else
    #include <sys/socket.h>
    #include <netinet/in.h>
    #include <arpa/inet.h>
    #include <unistd.h>
    #include <fcntl.h>
    #include <netdb.h>
#endif

#include <SDL2/SDL.h>
#include <SDL2/SDL_opengl.h>
#include <GL/glu.h>

#include "../../../packages/common/protocol.h"
#include "../../../packages/common/physics.h"
#include "../../../packages/simulation/local_game.h"

#define STATE_LOBBY 0
#define STATE_GAME_NET 1
#define STATE_GAME_LOCAL 2
int app_state = STATE_LOBBY;

float cam_yaw = 0.0f;
float cam_pitch = 0.0f;
float current_fov = 75.0f;

int sock = -1;
struct sockaddr_in server_addr;

void net_init() {
    #ifdef _WIN32
    WSADATA wsa; WSAStartup(MAKEWORD(2,2), &wsa);
    #endif
    sock = socket(AF_INET, SOCK_DGRAM, 0);
    #ifdef _WIN32
    u_long mode = 1; ioctlsocket(sock, FIONBIO, &mode);
    #else
    int flags = fcntl(sock, F_GETFL, 0); fcntl(sock, F_SETFL, flags | O_NONBLOCK);
    #endif

    struct hostent *he = gethostbyname("s.farthq.com");
    if (he) {
        server_addr.sin_family = AF_INET;
        server_addr.sin_port = htons(5314); 
        memcpy(&server_addr.sin_addr, he->h_addr_list[0], he->h_length);
    } else {
        server_addr.sin_family = AF_INET;
        server_addr.sin_port = htons(6969);
        server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    }

// Reuse Title Screen functions...
void draw_char(char c, float x, float y, float w, float h) {
    glBegin(GL_LINES);
    // (Simplified for HUD brevity - same vector font logic as previous phase)
    // Just drawing standard box for missing chars
    glVertex2f(x, y); glVertex2f(x+w, y);
    glVertex2f(x+w, y); glVertex2f(x+w, y+h);
    glVertex2f(x+w, y+h); glVertex2f(x, y+h);
    glVertex2f(x, y+h); glVertex2f(x, y);
    glEnd();
void draw_text_string(const char* s, float x, float y, float size) {
    float cursor = x;
    while(*s) {

        }
        draw_char(*s, cursor, y, size*0.6f, size);
        cursor += size * 0.8f;
        s++;
    }
void draw_lobby_screen() { /* Kept simple for now */ }

void draw_grid() {
    glBegin(GL_LINES);
    glColor3f(0.0f, 1.0f, 1.0f);
    for(int i=-100; i<=900; i+=5) {
        glVertex3f(i, 0, -100); glVertex3f(i, 0, 100);
        glVertex3f(-100, 0, i); glVertex3f(100, 0, i);
    }
    glEnd();

void draw_map() {
    for(int i=1; i<map_count; i++) {
        Box b = map_geo[i];
        glPushMatrix();
        glTranslatef(b.x, b.y, b.z);
        glScalef(b.w, b.h, b.d);
        glBegin(GL_QUADS);
        glColor3f(0.2f, 0.2f, 0.2f); 
        glVertex3f(-0.5,-0.5,0.5); glVertex3f(0.5,-0.5,0.5); glVertex3f(0.5,0.5,0.5); glVertex3f(-0.5,0.5,0.5);
        glVertex3f(-0.5,0.5,0.5); glVertex3f(0.5,0.5,0.5); glVertex3f(0.5,0.5,-0.5); glVertex3f(-0.5,0.5,-0.5);
        glVertex3f(-0.5,-0.5,-0.5); glVertex3f(0.5,-0.5,-0.5); glVertex3f(0.5,0.5,-0.5); glVertex3f(-0.5,0.5,-0.5);
        glVertex3f(-0.5,-0.5,-0.5); glVertex3f(-0.5,-0.5,0.5); glVertex3f(-0.5,0.5,0.5); glVertex3f(-0.5,0.5,-0.5);
        glVertex3f(0.5,-0.5,0.5); glVertex3f(0.5,-0.5,-0.5); glVertex3f(0.5,0.5,-0.5); glVertex3f(0.5,0.5,0.5);
        glEnd();
        glLineWidth(2.0f);
        glColor3f(1.0f, 0.0f, 1.0f); 
        glBegin(GL_LINE_LOOP);
        glVertex3f(-0.5, 0.5, 0.5); glVertex3f(0.5, 0.5, 0.5); glVertex3f(0.5, 0.5, -0.5); glVertex3f(-0.5, 0.5, -0.5);
        glEnd();
        glPopMatrix();
    }

void draw_gun_model(int weapon_id) {
    switch(weapon_id) {
        case WPN_KNIFE:   glColor3f(0.8f, 0.8f, 0.9f); glScalef(0.05f, 0.05f, 0.8f); break;
        case WPN_MAGNUM:  glColor3f(0.4f, 0.4f, 0.4f); glScalef(0.15f, 0.2f, 0.5f); break;
        case WPN_AR:      glColor3f(0.2f, 0.3f, 0.2f); glScalef(0.1f, 0.15f, 1.2f); break;
        case WPN_SHOTGUN: glColor3f(0.5f, 0.3f, 0.2f); glScalef(0.25f, 0.15f, 0.8f); break;
        case WPN_SNIPER:  glColor3f(0.1f, 0.1f, 0.15f); glScalef(0.08f, 0.12f, 2.0f); break;
    }
    glBegin(GL_QUADS); 
    glVertex3f(-1,1,1); glVertex3f(1,1,1); glVertex3f(1,1,-1); glVertex3f(-1,1,-1); 
    glVertex3f(-1,-1,1); glVertex3f(1,-1,1); glVertex3f(1,1,1); glVertex3f(-1,1,1); 
    glVertex3f(-1,-1,-1); glVertex3f(-1,1,-1); glVertex3f(1,1,-1); glVertex3f(1,-1,-1); 
    glVertex3f(1,-1,-1); glVertex3f(1,1,-1); glVertex3f(1,1,1); glVertex3f(1,-1,1); 
    glVertex3f(-1,-1,1); glVertex3f(-1,1,1); glVertex3f(-1,1,-1); glVertex3f(-1,-1,-1); 
    glEnd();

void draw_weapon_p(PlayerState *p) {
    glPushMatrix();
    glLoadIdentity();
    float kick = p->recoil_anim * 0.2f;
    float reload_dip = (p->reload_timer > 0) ? sinf(p->reload_timer * 0.2f) * 0.5f - 0.5f : 0.0f;
    float speed = sqrtf(p->vx*p->vx + p->vz*p->vz);
    float bob = sinf(SDL_GetTicks() * 0.015f) * speed * 0.15f; 
    float x_offset = (current_fov < 50.0f) ? 0.25f : 0.4f;
    glTranslatef(x_offset, -0.5f + kick + reload_dip + (bob * 0.5f), -1.2f + (kick * 0.5f) + bob);
    glRotatef(-p->recoil_anim * 10.0f, 1, 0, 0);
    draw_gun_model(p->current_weapon);
    glPopMatrix();

// --- NEW: DRAW HEAD ---
void draw_head(int weapon_id) {
    // Color matches gun
    switch(weapon_id) {
        case WPN_KNIFE:   glColor3f(0.8f, 0.8f, 0.9f); break;
        case WPN_MAGNUM:  glColor3f(0.4f, 0.4f, 0.4f); break;
        case WPN_AR:      glColor3f(0.2f, 0.3f, 0.2f); break;
        case WPN_SHOTGUN: glColor3f(0.5f, 0.3f, 0.2f); break;
        case WPN_SNIPER:  glColor3f(0.1f, 0.1f, 0.15f); break;
    }
    
    glBegin(GL_QUADS);
    // Simple Cube
    glVertex3f(-0.4, 0.8, 0.4); glVertex3f(0.4, 0.8, 0.4); glVertex3f(0.4, 0, 0.4); glVertex3f(-0.4, 0, 0.4);
    glVertex3f(-0.4, 0.8, -0.4); glVertex3f(0.4, 0.8, -0.4); glVertex3f(0.4, 0, -0.4); glVertex3f(-0.4, 0, -0.4);
    glVertex3f(-0.4, 0.8, 0.4); glVertex3f(0.4, 0.8, 0.4); glVertex3f(0.4, 0.8, -0.4); glVertex3f(-0.4, 0.8, -0.4);
    glVertex3f(-0.4, 0, 0.4); glVertex3f(0.4, 0, 0.4); glVertex3f(0.4, 0, -0.4); glVertex3f(-0.4, 0, -0.4);
    glVertex3f(-0.4, 0.8, 0.4); glVertex3f(-0.4, 0, 0.4); glVertex3f(-0.4, 0, -0.4); glVertex3f(-0.4, 0.8, -0.4);
    glVertex3f(0.4, 0.8, 0.4); glVertex3f(0.4, 0, 0.4); glVertex3f(0.4, 0, -0.4); glVertex3f(0.4, 0.8, -0.4);
    glEnd();

void draw_player_3rd(PlayerState *p) {
    glPushMatrix();
    glTranslatef(p->x, p->y + 2.0f, p->z);
    glRotatef(-p->yaw, 0, 1, 0); 
    
    if(p->health <= 0) glColor3f(0.2, 0, 0); 
    else glColor3f(1, 0, 0); 
    
    glPushMatrix();
    glScalef(1.2f, 3.8f, 1.2f);
    glBegin(GL_QUADS);
    glVertex3f(-0.5,-0.5,0.5); glVertex3f(0.5,-0.5,0.5); glVertex3f(0.5,0.5,0.5); glVertex3f(-0.5,0.5,0.5);
    glVertex3f(-0.5,0.5,0.5); glVertex3f(0.5,0.5,0.5); glVertex3f(0.5,0.5,-0.5); glVertex3f(-0.5,0.5,-0.5);
    glVertex3f(-0.5,-0.5,-0.5); glVertex3f(0.5,-0.5,-0.5); glVertex3f(0.5,0.5,-0.5); glVertex3f(-0.5,0.5,-0.5);
    glVertex3f(-0.5,-0.5,-0.5); glVertex3f(-0.5,-0.5,0.5); glVertex3f(-0.5,0.5,0.5); glVertex3f(-0.5,0.5,-0.5);
    glVertex3f(0.5,-0.5,0.5); glVertex3f(0.5,-0.5,-0.5); glVertex3f(0.5,0.5,-0.5); glVertex3f(0.5,0.5,0.5);
    glEnd();
    glPopMatrix();
    
    // DRAW HEAD
    glPushMatrix();
    glTranslatef(0, 2.0f, 0); // On top of body
    draw_head(p->current_weapon);
    glPopMatrix();
    
    // Weapon
    glPushMatrix();
    glTranslatef(0.5f, 1.0f, 0.5f);
    glRotatef(p->pitch, 1, 0, 0);   
    glScalef(0.8f, 0.8f, 0.8f);
    draw_gun_model(p->current_weapon);
    glPopMatrix();
    glPopMatrix();

void draw_projectiles() {}

void draw_hud(PlayerState *p) {
    glDisable(GL_DEPTH_TEST);
    glMatrixMode(GL_PROJECTION); glPushMatrix(); glLoadIdentity(); gluOrtho2D(0, 1280, 0, 720);
    glMatrixMode(GL_MODELVIEW); glPushMatrix(); glLoadIdentity();
    
    // CROSSHAIR
    glColor3f(0, 1, 0);
    if (current_fov < 50.0f) {
        glBegin(GL_LINES); glVertex2f(0, 360); glVertex2f(1280, 360); glVertex2f(640, 0); glVertex2f(640, 720); glEnd();
    } else {
        glLineWidth(2.0f);
        glBegin(GL_LINES); glVertex2f(630, 360); glVertex2f(650, 360); glVertex2f(640, 350); glVertex2f(640, 370); glEnd();
    }
    
    // HIT MARKER
    if (p->hit_feedback > 0) {
        if (p->hit_feedback == 20) glColor3f(1, 0, 1); // MAGENTA (Headshot)
        else glColor3f(0, 1, 1); // CYAN (Body)
        
        glBegin(GL_TRIANGLE_FAN);
        glVertex2f(640, 360); 
        for(int i=0; i<=20; i++) {
            float ang = (float)i / 20.0f * 6.28318f;
            glVertex2f(640 + cosf(ang)*15, 360 + sinf(ang)*15);
        }
        glEnd();
    }

    // --- BARS (Bottom Left) ---
    // Health (Red)
    glColor3f(0.2f, 0, 0); glRectf(50, 50, 250, 70);
    glColor3f(1.0f, 0, 0); glRectf(50, 50, 50 + (p->health * 2), 70);
    
    // Shield (Blue)
    glColor3f(0, 0, 0.2f); glRectf(50, 80, 250, 100);
    glColor3f(0.2f, 0.2f, 1.0f); glRectf(50, 80, 50 + (p->shield * 2), 100);

    // --- AMMO (Bottom Right) ---
    int w = p->current_weapon;
    int ammo = (w == WPN_KNIFE) ? 99 : p->ammo[w];
    glColor3f(1, 1, 0);
    for(int i=0; i<ammo; i++) {
        glRectf(1200 - (i*10), 50, 1205 - (i*10), 80);
    }
    
    glEnable(GL_DEPTH_TEST);
    glMatrixMode(GL_PROJECTION); glPopMatrix(); glMatrixMode(GL_MODELVIEW); glPopMatrix();

void draw_scene(PlayerState *render_p) {
    glClearColor(0.05f, 0.05f, 0.1f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glLoadIdentity();

    float cam_h = render_p->crouching ? 2.5f : EYE_HEIGHT;
    glRotatef(-cam_pitch, 1, 0, 0);
    glRotatef(-cam_yaw, 0, 1, 0);
    glTranslatef(-render_p->x, -(render_p->y + cam_h), -render_p->z);

    draw_grid();
    draw_map();
    draw_projectiles();
    
    for(int i=1; i<MAX_CLIENTS; i++) {
        if(local_state.players[i].active) {
            draw_player_3rd(&local_state.players[i]);
        }
    }

    draw_weapon_p(render_p);
    draw_hud(render_p);

int main(int argc, char* argv[]) {
    SDL_Init(SDL_INIT_VIDEO);
    SDL_Window *win = SDL_CreateWindow("SHANKPIT [SHIELDS UPDATED]", 100, 100, 1280, 720, SDL_WINDOW_OPENGL);
    SDL_GL_CreateContext(win);
    net_init();
    
    local_init_match(1);

    
    
    
    int game_state = STATE_MENU;
    int game_mode = MODE_BOTS;
    int running = 1;

    while (running) {

        // --- B-D-S-N GLITCH MENU ---
        if (game_state == STATE_MENU) {
            float glitch_x = (rand() % 100 > 95) ? (float)(rand() % 10 - 5) : 0;
            glClearColor(0.05f, 0.05f, 0.1f, 1.0f);
            glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
            glLoadIdentity();
            
            // Note: render_background_canyon and draw_text_centered must be defined or replaced with draw_text_string
            draw_text_string("SHANKPIT", 500 + glitch_x, 400, 4.0f);
            draw_text_string("[B] BOTS   [D] DEV/DEMO", 450, 300, 1.2f);
            draw_text_string("[S] SERVER [N] NETWORK", 450, 260, 1.2f);

            const Uint8 *k = SDL_GetKeyboardState(NULL);
            if (k[SDL_SCANCODE_B]) { game_mode = MODE_BOTS; game_state = STATE_PLAYING; local_init_match(31); SDL_SetRelativeMouseMode(SDL_TRUE); }
            if (k[SDL_SCANCODE_D]) { game_mode = MODE_DEV;  game_state = STATE_PLAYING; local_init_match(1);  SDL_SetRelativeMouseMode(SDL_TRUE); }
            if (k[SDL_SCANCODE_S]) { game_mode = MODE_SERV; game_state = STATE_PLAYING; local_init_match(31); USE_NEURAL_NET = 1; SDL_SetRelativeMouseMode(SDL_TRUE); }
            if (k[SDL_SCANCODE_N]) { game_mode = MODE_NET;  game_state = STATE_PLAYING; SDL_SetRelativeMouseMode(SDL_TRUE); }
            
            SDL_GL_SwapWindow(win);
            continue; 
        }

        if (game_state == STATE_MENU) {
            float glitch_x = (rand() % 100 > 95) ? (float)(rand() % 10 - 5) : 0;
            render_background_canyon(); 
            draw_text_centered("SHANKPIT", (SCREEN_HEIGHT/2 - 40) + glitch_x, 4.0f);
            draw_text_centered("[B] BOTS   [D] DEV/DEMO", SCREEN_HEIGHT/2 + 10, 1.2f);
            draw_text_centered("[S] SERVER [N] NETWORK", SCREEN_HEIGHT/2 + 35, 1.2f);

            if (is_key_pressed('B')) { game_mode = MODE_BOTS; game_state = STATE_PLAYING; init_local_player(); }
            if (is_key_pressed('D')) { game_mode = MODE_DEV;  game_state = STATE_PLAYING; }
            if (is_key_pressed('S')) { game_mode = MODE_SERV; game_state = STATE_PLAYING; start_server(); }
            if (is_key_pressed('N')) { game_mode = MODE_NET;  game_state = STATE_PLAYING; connect_to_lan(); }
            continue; 
        }

        if (game_state == STATE_MENU) {
            float glitch_x = (rand() % 100 > 95) ? (float)(rand() % 10 - 5) : 0;
            render_background_canyon(); 
            draw_text_centered("SHANKPIT", (SCREEN_HEIGHT/2 - 40) + glitch_x, 4.0f);
            draw_text_centered("[B] BOTS   [D] DEV/DEMO", SCREEN_HEIGHT/2 + 10, 1.2f);
            draw_text_centered("[S] SERVER [N] NETWORK", SCREEN_HEIGHT/2 + 35, 1.2f);

            if (is_key_pressed('B')) { game_mode = MODE_BOTS; game_state = STATE_PLAYING; init_local_player(); }
            if (is_key_pressed('D')) { game_mode = MODE_DEV;  game_state = STATE_PLAYING; }
            if (is_key_pressed('S')) { game_mode = MODE_SERV; game_state = STATE_PLAYING; start_server(); }
            if (is_key_pressed('N')) { game_mode = MODE_NET;  game_state = STATE_PLAYING; connect_to_lan(); }
            continue; 
        }

        // --- B-D-S-N GLITCH MENU ---
        if (game_state == STATE_MENU) {
            float glitch_x = (rand() % 100 > 95) ? (float)(rand() % 10 - 5) : 0;
            render_background_canyon(); 
            draw_text_centered("SHANKPIT", (SCREEN_HEIGHT/2 - 40) + glitch_x, 4.0f);
            draw_text_centered("[B] BOTS   [D] DEV/DEMO", SCREEN_HEIGHT/2 + 10, 1.2f);
            draw_text_centered("[S] SERVER [N] NETWORK", SCREEN_HEIGHT/2 + 35, 1.2f);

            if (is_key_pressed(KEY_B)) { game_mode = MODE_BOTS; game_state = STATE_PLAYING; init_local_player(); }
            if (is_key_pressed(KEY_D)) { game_mode = MODE_DEV;  game_state = STATE_PLAYING; }
            if (is_key_pressed(KEY_S)) { game_mode = MODE_SERV; game_state = STATE_PLAYING; start_server(); }
            if (is_key_pressed(KEY_N)) { game_mode = MODE_NET;  game_state = STATE_PLAYING; connect_to_lan(); }
            continue; 
        }


            SDL_Event e;
        while(SDL_PollEvent(&e)) {
            if(e.type == SDL_QUIT) running = 0;
            
            if (app_state == STATE_LOBBY) {
                if(e.type == SDL_KEYDOWN) {
                    if (e.key.keysym.sym == SDLK_d) {
                        app_state = STATE_GAME_LOCAL;
                        USE_NEURAL_NET = 0;
                        local_init_match(1);
                        SDL_SetRelativeMouseMode(SDL_TRUE);
                        glMatrixMode(GL_PROJECTION); glLoadIdentity(); gluPerspective(75.0, 1280.0/720.0, 0.1, 1000.0);
                        glMatrixMode(GL_MODELVIEW); glEnable(GL_DEPTH_TEST);
                    }
                    if (e.key.keysym.sym == SDLK_b) {
                        app_state = STATE_GAME_LOCAL;
                        USE_NEURAL_NET = 0; 
                        local_init_match(31); 
                        SDL_SetRelativeMouseMode(SDL_TRUE);
                        glMatrixMode(GL_PROJECTION); glLoadIdentity(); gluPerspective(75.0, 1280.0/720.0, 0.1, 1000.0);
                        glMatrixMode(GL_MODELVIEW); glEnable(GL_DEPTH_TEST);
                    }
                    if (e.key.keysym.sym == SDLK_s) { 
                        app_state = STATE_GAME_LOCAL;
                        USE_NEURAL_NET = 1; 
                        local_init_match(31);
                        printf("MODE S ACTIVATED.\n");
                        SDL_SetRelativeMouseMode(SDL_TRUE);
                        glMatrixMode(GL_PROJECTION); glLoadIdentity(); gluPerspective(75.0, 1280.0/720.0, 0.1, 1000.0);
                        glMatrixMode(GL_MODELVIEW); glEnable(GL_DEPTH_TEST);
                    }
                    if (e.key.keysym.sym == SDLK_n) {
                        app_state = STATE_GAME_NET;
                        SDL_SetRelativeMouseMode(SDL_TRUE);
                        glMatrixMode(GL_PROJECTION); glLoadIdentity(); gluPerspective(75.0, 1280.0/720.0, 0.1, 1000.0);
                        glMatrixMode(GL_MODELVIEW); glEnable(GL_DEPTH_TEST);
                    }
                }
            } 
            else {
                if(e.type == SDL_KEYDOWN) {
                    if (e.key.keysym.sym == SDLK_ESCAPE) {
                        app_state = STATE_LOBBY;
                        SDL_SetRelativeMouseMode(SDL_FALSE);
                        glDisable(GL_DEPTH_TEST);
                        glMatrixMode(GL_PROJECTION); glLoadIdentity(); gluOrtho2D(0, 1280, 0, 720);
                        glMatrixMode(GL_MODELVIEW); glLoadIdentity();
                    }
                }
                if(e.type == SDL_MOUSEMOTION) {
                    float sens = (current_fov < 50.0f) ? 0.05f : 0.15f; 
                    cam_yaw -= e.motion.xrel * sens;
                    if(cam_yaw > 360) cam_yaw -= 360; if(cam_yaw < 0) cam_yaw += 360;
                    cam_pitch -= e.motion.yrel * sens;
                    if(cam_pitch > 89) cam_pitch = 89; if(cam_pitch < -89) cam_pitch = -89;
                }
            }
        }

        if (app_state == STATE_LOBBY) {
             glMatrixMode(GL_PROJECTION); glLoadIdentity(); gluOrtho2D(0, 1280, 0, 720);
             glMatrixMode(GL_MODELVIEW); glLoadIdentity();
             draw_lobby_screen(); // Re-use old drawing function (omitted for brevity but assumed present)
             
             // Redraw menu if needed
             glClearColor(0.1f, 0.1f, 0.2f, 1.0f);
             glClear(GL_COLOR_BUFFER_BIT);
             glLoadIdentity();
             glColor3f(1, 1, 0);
             glBegin(GL_LINES); 
             // D, B, N, S (Basic letters)
             glVertex2f(200, 300); glVertex2f(200, 400); glVertex2f(200, 400); glVertex2f(250, 350);
             glVertex2f(250, 350); glVertex2f(200, 300);
             glVertex2f(400, 300); glVertex2f(400, 400); glVertex2f(400, 350); glVertex2f(450, 350);
             glVertex2f(450, 350); glVertex2f(450, 300); glVertex2f(450, 350); glVertex2f(450, 400);
             glVertex2f(450, 400); glVertex2f(400, 400); glVertex2f(450, 300); glVertex2f(400, 300);
             glVertex2f(600, 300); glVertex2f(600, 400); 
             glVertex2f(600, 400); glVertex2f(650, 300);
             glVertex2f(650, 300); glVertex2f(650, 400);
             glColor3f(0, 1, 1); 
             glVertex2f(850, 300); glVertex2f(800, 300); glVertex2f(800, 350); glVertex2f(850, 350);
             glVertex2f(850, 350); glVertex2f(850, 400); glVertex2f(850, 400); glVertex2f(800, 400);
             glEnd();
        } 
        else if (app_state == STATE_GAME_LOCAL) {
            const Uint8 *k = SDL_GetKeyboardState(NULL);
            float fwd=0, str=0;
            if(k[SDL_SCANCODE_W]) fwd+=1; if(k[SDL_SCANCODE_S]) fwd-=1;
            if(k[SDL_SCANCODE_D]) str+=1; if(k[SDL_SCANCODE_A]) str-=1;
            int jump = k[SDL_SCANCODE_SPACE];
            int crouch = k[SDL_SCANCODE_LCTRL];
            int shoot = (SDL_GetMouseState(NULL, NULL) & SDL_BUTTON(SDL_BUTTON_LEFT));
            int rmb = (SDL_GetMouseState(NULL, NULL) & SDL_BUTTON(SDL_BUTTON_RIGHT));
            int reload = k[SDL_SCANCODE_R];
            int wpn = -1;
            if(k[SDL_SCANCODE_1]) wpn=0; if(k[SDL_SCANCODE_2]) wpn=1; if(k[SDL_SCANCODE_3]) wpn=2;
            if(k[SDL_SCANCODE_4]) wpn=3; if(k[SDL_SCANCODE_5]) wpn=4;

            // --- REGEN LOGIC (Simulation side logic handled in physics.h but timer needs ticking)
            if (local_state.players[0].shield_regen_timer > 0) local_state.players[0].shield_regen_timer--;
            else if (local_state.players[0].shield < 100) local_state.players[0].shield++;

            float target_fov = (rmb && local_state.players[0].current_weapon == WPN_SNIPER) ? 20.0f : 75.0f;
            current_fov += (target_fov - current_fov) * 0.2f;
            glMatrixMode(GL_PROJECTION); glLoadIdentity(); 
            gluPerspective(current_fov, 1280.0/720.0, 0.1, 1000.0);
            glMatrixMode(GL_MODELVIEW);

            local_update(fwd, str, cam_yaw, cam_pitch, shoot, wpn, jump, crouch, reload);
            draw_scene(&local_state.players[0]);
        }
        else if (app_state == STATE_GAME_NET) {
            draw_scene(&local_state.players[0]); 
        }

        SDL_GL_SwapWindow(win);
        SDL_Delay(16);
    }
    SDL_Quit();
    return 0;

--- END: apps/lobby/src/main.c ---

--- FILE: packages/common/protocol.h ---
#ifndef PROTOCOL_H
#define PROTOCOL_H

#define MAX_CLIENTS 70
#define MAX_WEAPONS 5
#define MAX_PROJECTILES 1024

#define WPN_KNIFE 0
#define WPN_MAGNUM 1
#define WPN_AR 2
#define WPN_SHOTGUN 3
#define WPN_SNIPER 4

#define RELOAD_TIME 60
#define SHIELD_REGEN_DELAY 180 // 3 Seconds @ 60 FPS

typedef struct {
    int id; int dmg; int rof; int cnt; float spr; int ammo_max;
} WeaponStats;

static const WeaponStats WPN_STATS[MAX_WEAPONS] = {
    {WPN_KNIFE,   200, 20, 1, 0.0f,  0},   
    {WPN_MAGNUM,  45, 25, 1, 0.0f,  6},   
    {WPN_AR,      20, 6,  1, 0.04f, 30},  
    {WPN_SHOTGUN, 64,  50, 8, 0.15f, 8},   
    {WPN_SNIPER,  101, 70, 1, 0.0f,  5}    
};

typedef struct {
    int active;
    float x, y, z;
    float vx, vy, vz;
    int owner_id;
} Projectile;

typedef struct {
    int id;
    int active;
    int is_bot;
    
    float x, y, z;
    float vx, vy, vz;
    float yaw, pitch;
    int on_ground;
    
    float in_fwd;
    float in_strafe;
    int in_jump;
    int in_shoot;
    int in_reload;
    int crouching;
    
    int current_weapon;
    int ammo[MAX_WEAPONS];
    int reload_timer;
    int attack_cooldown;
    int is_shooting;
    int jump_timer;
    
    int health;
    int shield;             // <--- NEW
    int shield_regen_timer; // <--- NEW
    
    int kills;
    int hit_feedback;       // 10 = Body, 20 = Head
    float recoil_anim;
    
    float accumulated_reward; 
} PlayerState;

typedef struct {
    PlayerState players[MAX_CLIENTS];
    Projectile projectiles[MAX_PROJECTILES];
    int server_tick;
} ServerState;

#endif

--- END: packages/common/protocol.h ---

--- FILE: packages/common/physics.h ---
#ifndef PHYSICS_H
#define PHYSICS_H
#include <math.h>
#include <stdlib.h>
#include "protocol.h"

// --- TURBO TUNING ---
#define GRAVITY 0.018f
#define JUMP_FORCE 0.61f
#define MAX_SPEED 0.75f
#define FRICTION 0.42f
#define ACCEL 1.618f
#define STOP_SPEED 0.1f
#define MAX_AIR_SPEED 0.2f
#define EYE_HEIGHT 4.0f
#define HEAD_SIZE 0.8f
#define HEAD_OFFSET 4.5f

// KNIFE RANGE LIMIT
#define MELEE_RANGE_SQ 100.0f // 10.0 * 10.0

typedef struct { float x, y, z, w, h, d; } Box;

// MAP GEOMETRY (Standard 40-count map + auto-calc)
static Box map_geo[] = {
    {0, -1, 0, 900, 2, 300}, // Floor
    {0, 2.0, 0, 24, 4, 24}, {0, 5.0, 0, 14, 2, 14}, {0, 8.0, 0, 6, 4, 6}, // Zig
    {300, 10, 0, 10, 20, 10}, {310, 2, 0, 4, 2, 4}, {308, 5, 5, 4, 2, 4}, // East Spire
    {-300, 10, 0, 10, 20, 10}, {-310, 2, 0, 4, 2, 4}, {-308, 5, -5, 4, 2, 4}, // West Spire
    {100, 2, 0, 40, 4, 2}, {-100, 2, 0, 40, 4, 2}, // Spine
    {150, 2, 40, 6, 4, 6}, {160, 2, 35, 2, 4, 10}, {140, 1, 45, 4, 2, 4}, // E Ruins
    {150, 2, -40, 6, 4, 6}, {160, 2, -35, 2, 4, 10}, {180, 4, 0, 8, 8, 8},
    {-150, 2, 40, 6, 4, 6}, {-160, 2, 35, 2, 4, 10}, {-140, 1, 45, 4, 2, 4}, // W Ruins
    {-150, 2, -40, 6, 4, 6}, {-160, 2, -35, 2, 4, 10}, {-180, 4, 0, 8, 8, 8},
    {250, 5, 0, 4, 1, 4}, {200, 7, 10, 4, 1, 4}, {150, 9, -10, 4, 1, 4}, // E Parkour
    {-250, 5, 0, 4, 1, 4}, {-200, 7, -10, 4, 1, 4}, {-150, 9, 10, 4, 1, 4}, // W Parkour
    {50, 2, 80, 4, 4, 4}, {50, 2, -80, 4, 4, 4}, {-50, 2, 80, 4, 4, 4}, {-50, 2, -80, 4, 4, 4}, 
    {220, 1, 50, 4, 2, 8}, {-220, 1, -50, 4, 2, 8}, // Cover
    
    // BASES (Alpha)
    {350, 5, 20, 40, 10, 2}, {350, 5, -20, 40, 10, 2}, {370, 5, 0, 2, 10, 40}, {330, 5, 12, 2, 10, 16}, {330, 5, -12, 2, 10, 16},
    {350, 10, 15, 40, 1, 10}, {350, 10, -15, 40, 1, 10}, {365, 10, 0, 10, 1, 20}, {335, 10, 0, 10, 1, 20},
    {325, 2, 25, 6, 2, 6}, {328, 4, 25, 6, 2, 6}, {331, 6, 25, 6, 2, 6}, {335, 8, 25, 6, 2, 6}, {360, 1, 0, 4, 2, 4},
    
    // BASES (Omega)
    {-350, 5, 20, 40, 10, 2}, {-350, 5, -20, 40, 10, 2}, {-370, 5, 0, 2, 10, 40}, {-330, 5, 12, 2, 10, 16}, {-330, 5, -12, 2, 10, 16},
    {-350, 10, 15, 40, 1, 10}, {-350, 10, -15, 40, 1, 10}, {-365, 10, 0, 10, 1, 20}, {-335, 10, 0, 10, 1, 20},
    {-325, 2, -25, 6, 2, 6}, {-328, 4, -25, 6, 2, 6}, {-331, 6, -25, 6, 2, 6}, {-335, 8, -25, 6, 2, 6}, {-360, 1, 0, 4, 2, 4},

    // WALLS
    {0, 25, 250, 1200, 50, 200}, {0, 25, -250, 1200, 50, 200}, // N/S Walls
    {550, 25, 0, 200, 50, 800}, {-550, 25, 0, 200, 50, 800} // E/W Walls
};
static int map_count = sizeof(map_geo) / sizeof(Box);

float phys_rand_f() { return ((float)(rand()%1000)/500.0f) - 1.0f; }

// Return: 0=Miss, 1=Body, 2=Head
int check_hit_location(float ox, float oy, float oz, float dx, float dy, float dz, PlayerState *target) {
    if (!target->active) return 0;
    
    float tx = target->x; 
    float tz = target->z;
    
    // 1. Check Head
    float head_y = target->y + HEAD_OFFSET;
    float h_size = HEAD_SIZE;
    
    float vx = tx - ox, vy = head_y - oy, vz = tz - oz;
    float t = vx*dx + vy*dy + vz*dz;
    if (t > 0) {
        float cx = ox + dx*t, cy = oy + dy*t, cz = oz + dz*t;
        float dist_sq = (tx-cx)*(tx-cx) + (head_y-cy)*(head_y-cy) + (tz-cz)*(tz-cz);
        if (dist_sq < (h_size*h_size)) return 2; 
    }

    // 2. Check Body
    float body_y = target->y + 2.0f;
    vx = tx - ox; vy = body_y - oy; vz = tz - oz;
    t = vx*dx + vy*dy + vz*dz;
    if (t > 0) {
        float cx = ox + dx*t, cy = oy + dy*t, cz = oz + dz*t;
        float dist_sq = (tx-cx)*(tx-cx) + (body_y-cy)*(body_y-cy) + (tz-cz)*(tz-cz);
        if (dist_sq < 7.2f) return 1; 
    }
    
    return 0;
}

void apply_friction(PlayerState *p) {
    float speed = sqrtf(p->vx*p->vx + p->vz*p->vz);
    if (speed < 0.001f) { p->vx = 0; p->vz = 0; return; }
    if (!p->on_ground) return; 
    float control = (speed < STOP_SPEED) ? STOP_SPEED : speed;
    float drop = control * FRICTION;
    float newspeed = speed - drop;
    if (newspeed < 0) newspeed = 0;
    newspeed /= speed;
    p->vx *= newspeed; p->vz *= newspeed;
}

void accelerate(PlayerState *p, float wish_x, float wish_z, float wish_speed, float accel) {
    float current_speed = (p->vx * wish_x) + (p->vz * wish_z);
    float add_speed = wish_speed - current_speed;
    if (add_speed <= 0) return;
    float acc_speed = accel * wish_speed;
    if (acc_speed > add_speed) acc_speed = add_speed;
    p->vx += acc_speed * wish_x; p->vz += acc_speed * wish_z;
}

void resolve_collision(PlayerState *p) {
    float pw = 0.6f; float ph = p->crouching ? 2.0f : 4.0f; 
    p->on_ground = 0;
    if (p->y < 0) { p->y = 0; p->vy = 0; p->on_ground = 1; }
    for(int i=1; i<map_count; i++) {
        Box b = map_geo[i];
        if (p->x + pw > b.x - b.w/2 && p->x - pw < b.x + b.w/2 &&
            p->z + pw > b.z - b.d/2 && p->z - pw < b.z + b.d/2) {
            if (p->y < b.y + b.h/2 && p->y + ph > b.y - b.h/2) {
                float prev_y = p->y - p->vy;
                if (prev_y >= b.y + b.h/2) {
                    p->y = b.y + b.h/2; p->vy = 0; p->on_ground = 1;
                } else {
                    float dx = p->x - b.x; float dz = p->z - b.z;
                    float w = (b.w > 0.1f) ? b.w : 1.0f;
                    float d = (b.d > 0.1f) ? b.d : 1.0f;
                    if (fabs(dx)/w > fabs(dz)/d) { 
                        p->vx = 0; 
                        p->x = (dx > 0) ? b.x + b.w/2 + pw : b.x - b.w/2 - pw;
                    } else { 
                        p->vz = 0; 
                        p->z = (dz > 0) ? b.z + b.d/2 + pw : b.z - b.d/2 - pw;
                    }
                }
            }
        }
    }
}

void update_weapons(PlayerState *p, PlayerState *targets, int shoot, int reload) {
    if (p->reload_timer > 0) p->reload_timer--;
    if (p->attack_cooldown > 0) p->attack_cooldown--;
    if (p->is_shooting > 0) p->is_shooting--;

    int w = p->current_weapon;
    if (reload && p->reload_timer == 0 && w != WPN_KNIFE) {
        if (p->ammo[w] < WPN_STATS[w].ammo_max) p->reload_timer = RELOAD_TIME;
    }
    if (p->reload_timer == 1) p->ammo[w] = WPN_STATS[w].ammo_max;

    if (shoot && p->attack_cooldown == 0 && p->reload_timer == 0) {
        if (w == WPN_KNIFE || p->ammo[w] > 0) {
            p->is_shooting = 5; p->recoil_anim = 1.0f;
            p->attack_cooldown = WPN_STATS[w].rof;
            if (w != WPN_KNIFE) p->ammo[w]--;
            
            float r = -p->yaw * 0.0174533f;
            float rp = p->pitch * 0.0174533f;
            float dx = sinf(r) * cosf(rp);
            float dy = sinf(rp);
            float dz = -cosf(r) * cosf(rp);
            
            if (WPN_STATS[w].spr > 0) {
                dx += phys_rand_f() * WPN_STATS[w].spr;
                dy += phys_rand_f() * WPN_STATS[w].spr;
                dz += phys_rand_f() * WPN_STATS[w].spr;
            }

            for(int i=0; i<MAX_CLIENTS; i++) {
                if (p == &targets[i]) continue;
                if (!targets[i].active) continue;

                // --- FIX: KNIFE RANGE CHECK ---
                if (w == WPN_KNIFE) {
                    float kx = p->x - targets[i].x;
                    float ky = p->y - targets[i].y;
                    float kz = p->z - targets[i].z;
                    float kdist = kx*kx + ky*ky + kz*kz;
                    if (kdist > MELEE_RANGE_SQ + 22.0f ) continue; // Too far!
                }

                int hit_type = check_hit_location(p->x, p->y + EYE_HEIGHT, p->z, dx, dy, dz, &targets[i]);
                
                if (hit_type > 0) {
                    int damage = WPN_STATS[w].dmg;
                    targets[i].shield_regen_timer = SHIELD_REGEN_DELAY;
                    
                    if (hit_type == 2 && targets[i].shield <= 0) {
                        damage *= 3; 
                        p->hit_feedback = 20; 
                    } else {
                        p->hit_feedback = 10; 
                    }
                    
                    if (targets[i].shield > 0) {
                        if (targets[i].shield >= damage) {
                            targets[i].shield -= damage;
                            damage = 0;
                        } else {
                            damage -= targets[i].shield;
                            targets[i].shield = 0;
                        }
                    }
                    
                    targets[i].health -= damage;
                    
                    if(targets[i].health <= 0) {
                        p->kills++;
                        targets[i].health = 100;
                        targets[i].shield = 100; 
                        targets[i].x = (rand()%800)-400; 
                        targets[i].z = (rand()%200)-100; 
                        targets[i].y = 10;
                    }
                }
            }
        } else {
            p->attack_cooldown = 10; 
        }
    }
}
#endif

--- END: packages/common/physics.h ---

--- FILE: apps/training/headless.c ---

#include "../../packages/simulation/local_game.h"

// Export functions for Python
void sim_init(int bots) {
    local_init_match(bots);
}

void sim_step(float fwd, float strafe, float yaw, float pitch, int shoot, int jump) {
    // We are controlling Player 0 (The Agent)
    // The "bots" in the match are the opponents
    local_update(fwd, strafe, yaw, pitch, shoot, -1, jump, 0, 0);
}

ServerState* sim_get_state() {
    return &local_state;
}

--- END: apps/training/headless.c ---
